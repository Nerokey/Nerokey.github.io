{"meta":{"title":"Nerokey's Blog","subtitle":"个人博客，此将记录我学习的点滴。","description":"人没有梦想，和咸鱼有什么区别！","author":"Nerokey","url":"http://www.nerokey.iofo"},"pages":[{"title":"关于我","date":"2017-10-21T06:33:25.000Z","updated":"2017-10-23T13:06:11.277Z","comments":true,"path":"about/index.html","permalink":"http://www.nerokey.iofo/about/index.html","excerpt":"","text":"目前咸鱼一只！正在努力学习，期待翻身的那一天。。。 这是我的个人博客，感谢大家支持！！！ 热爱IT技术，Coding Fun！！"},{"title":"分类","date":"2017-10-21T04:48:06.000Z","updated":"2017-10-21T04:48:52.940Z","comments":true,"path":"categories/index.html","permalink":"http://www.nerokey.iofo/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-21T04:42:18.000Z","updated":"2017-10-21T04:42:58.863Z","comments":true,"path":"tags/index.html","permalink":"http://www.nerokey.iofo/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java集合框架之Map","slug":"Java集合框架之Map","date":"2017-11-12T00:36:16.000Z","updated":"2017-11-12T02:11:58.889Z","comments":true,"path":"2017/11/12/Java集合框架之Map/","link":"","permalink":"http://www.nerokey.iofo/2017/11/12/Java集合框架之Map/","excerpt":"什么是MapMap与list以及set一样是位于java.util包下定义的一个接口。map是键值对的存在，将键值映射到对象中，其规定：一个映射不能包含重复的键；每个键最多只能映射到一个值。其实现的子类有HashMap、Hashtable、LinkedHashMap以及TreeMap等等，下面我们就来看看这四种实现类的用法和区别","text":"什么是MapMap与list以及set一样是位于java.util包下定义的一个接口。map是键值对的存在，将键值映射到对象中，其规定：一个映射不能包含重复的键；每个键最多只能映射到一个值。其实现的子类有HashMap、Hashtable、LinkedHashMap以及TreeMap等等，下面我们就来看看这四种实现类的用法和区别 1. HashMap他是基于哈希表的实现，不能保证映射顺序相同。他也是线程不同步的，所以必须添加外部代码使得线程同步。1)、创建map对象以及添加键值对：使用put()方法添加键值对123456789import java.util.HashMap;//使用了泛型，规定key必须为String类型，值必须为double类型HashMap&lt;String, Double&gt; map = new HashMap&lt;String, Double&gt;(); map.put(&quot;语文&quot;, 84.0);map.put(&quot;数学&quot;, 91.0);map.put(null, null); //允许添加的键和都为nullmap.put(&quot;英语&quot;, 72.5); 2)、遍历输出：有两种方式123456789101112131415//使用Iterator迭代器遍历HashMapIterator iter = map.keySet().iterator();while(iter.hasNext())&#123; //System.out.print(iter.next()); //这样只能访问到key值，而不能访问key对应的value String key = (String) iter.next(); System.out.println(key+&quot;:&quot;+map.get(key)); //使用HashMap中的get()方法访问key对应的值&#125; System.out.println(&quot;-------------------&quot;);//使用enterSet()方法的foreach循环遍历打印Set&lt;Entry&lt;String, Double&gt;&gt; sets = map.entrySet(); for(Entry&lt;String, Double&gt; entry : sets) &#123; System.out.println(entry.getKey() + &quot;：&quot;+entry.getValue()); &#125; 运行结果：可以看到两者的效果是一样的，发现遍历输出的顺序与添加顺序是不一样的。所以他是无序的 2. LinkedHashMap他是HashMap的直接子类，但是他是链表实现。LinkedHashMap可以认为是HashMap+LinkedList，即它既使用HashMap操作数据结构，又使用LinkedList维护插入元素的先后顺序。LinkedHashMap虽然增加了时间和空间上的开销，但是通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代的顺序。该迭代顺序可以是插入顺序或者是访问顺序。它具有如下特点：| 项目 | 结论 ||:–:|:–:||LinkedHashMap是否允许null值|Key和Value都允许为null||LinkedHashMap是否允许重复数据|Key重复会覆盖、Value允许重复||LinkedHashMap是否有序|有序||LinkedHashMap是否线程安全|非线程安全|1)、创建对象及添加数据：使用put()添加数据123456789import java.util.LinkedHashMap;LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;(); map.put(&quot;西游记&quot;, &quot;吴承恩&quot;);map.put(&quot;三国演义&quot;, &quot;罗贯中&quot;);map.put(&quot;红楼梦&quot;, &quot;曹雪芹&quot;);map.put(null, null); //允许添加null值map.put(&quot;水浒传&quot;, &quot;施耐庵&quot;); 2)、遍历输出：123456//与HashMap一样使用迭代器输出Iterator iter = map.keySet().iterator();while(iter.hasNext())&#123; String key = (String) iter.next(); System.out.println(key+&quot;：&quot;+map.get(key)); //使用HashMap中的get()方法访问key对应的值&#125; 输出结果为：可以看出输出顺序与添加顺序一样![](http://oxua0flmy.bkt.clouddn.com/20171112100137.png 3. Hashtable4. TreeMap","categories":[{"name":"Java","slug":"Java","permalink":"http://www.nerokey.iofo/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.nerokey.iofo/tags/java/"},{"name":"集合","slug":"集合","permalink":"http://www.nerokey.iofo/tags/集合/"}]},{"title":"Java中的集合之Set","slug":"Java中的集合之Set","date":"2017-11-08T23:46:40.000Z","updated":"2017-11-11T08:33:08.358Z","comments":true,"path":"2017/11/09/Java中的集合之Set/","link":"","permalink":"http://www.nerokey.iofo/2017/11/09/Java中的集合之Set/","excerpt":"什么是Setset也是java集合框架中的一种，一样是一种容器，用来存放对象等等，但是他不会记住对象的存储顺序，也不允许同一个set集合中出现相同的元素(这是和list不同的地方)。已实现的类有HashSet、LinkedHashSet、TreeSet等等。 1. HashSetHashSet按照Hash算法存储集合中的元素，具有很好的存取和查找性能。当向HashSet中添加一些元素时，HashSet会根据该对象的HashCode()方法来得到该对象的HashCode值，然后根据这些HashCode的值来决定元素的位置。","text":"什么是Setset也是java集合框架中的一种，一样是一种容器，用来存放对象等等，但是他不会记住对象的存储顺序，也不允许同一个set集合中出现相同的元素(这是和list不同的地方)。已实现的类有HashSet、LinkedHashSet、TreeSet等等。 1. HashSetHashSet按照Hash算法存储集合中的元素，具有很好的存取和查找性能。当向HashSet中添加一些元素时，HashSet会根据该对象的HashCode()方法来得到该对象的HashCode值，然后根据这些HashCode的值来决定元素的位置。 HashSet的特点： 1. 存储顺序和添加的顺序不同 2. HashSet是线程不同步的，如果多个线程同时访问一个HashSet，假设有两个或更多的线程修改了集合中的值，则必须通过代码使线程同步。 3. HastSet允许集合中的元素为null。 在HashSet集合中，判断两个元素相同的标准是：两个对象通过equals()方法相等，且HashCode()方法的返回值也相等。如果有两个元素通过equals()方法比较相等，而HashCode()的返回值不同，HashSet会将这两个对象保存在不同的地方。 1、添加元素：使用add()方法添加元素123456789HashSet hs = new HashSet(); hs.add(&quot;abcdef&quot;);hs.add(1234);hs.add(3.1415);hs.add(null); //允许添加null值hs.add(false);hs.add(1234); //虽然没有报错，但是会被输出只有一个hs.add(new Persion(&quot;张三&quot;, 20)); 2、遍历输出：使用Iterator迭代器遍历1234Iterator iter = hs.iterator();while(iter.hasNext())&#123; System.out.println(iter.next());&#125; 3、其他一些方法：1234567891011//清空集合内元素 hs.clear();//克隆一个HashSet HashSet hash = (HashSet) hs.clone();//获取HashSet额长度int i = hs.size();//移除集合中的某个元素，返回布尔类型，表示是否成功boolean flag = hs.remove(1234); 注意： 如果向HashSet中添加一个可变对象后，后面的对象修改了该可变对象的实例变量，则可能导致它与集合中的其他元素相同。 2. LinkedHashSetLikedHashSet是HashSet的子类，它也是根据元素的HashCode值进来决定元素的存储位置，但它能够同时使用链表来维护元素的添加次序，使得元素能以插入顺序保存。其大部分方法使用和HsahSet几乎一样。由于他添加元素是有顺序的，使得其性能会比HashSet要好，但是在插入元素时就要不如HashSet了。 3. TreeSetTreeSet是SortedSet接口的实现类，TreeSet可以保证了集合元素处于排序状态（所谓排序状态，就是元素按照一定的规则排序，比如升序排列，降序排列）。与HashSet集合相比：1、Comparator comparator():如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator，如果采用了自然排序，则返回null。 2、Object first(): 返回集合中的第一个元素。 3、Object last():返回集合中的最后一个元素。 4、Object lower(Object e)：返回集合中位于指定元素e之前的元素（即小于指定元素的最大元素，参考元素e不必是集合中的元素）。 5、Object higher(Object e):返回集合中位于指定元素e之后的元素（即大于指定元素的最小元素，参考元素e不必是集合中的元素）。 6、SortedSet subSet(Object fromElement, Object toElement): 返回集合中所有在fromElemt和toElement之间的元素（包含fromElent本身，不包含toElement本身）。 7、SortedSet headSet(Object toElement): 返回此set的子集，由小于toElement的元素组成。 8、SortedSet tailSet(Object fromElement):返回此set的子集，由大于或等于fromElement的元素组成。 比如我们添加一些元素：123456789TreeSet ts = new TreeSet();ts.add(10);ts.add(-8);ts.add(18);ts.add(10); //没有报错，但是输出只有一个ts.add(26);//ts.add(3.14); //允许添加其他类型的元素//ts.add(&quot;abc&quot;); //报错，原因同上 运行结果为：只输出了一个10，并且输出结果是从小到大排序的。 TreeSet支持两种排序方法：自然排序和定制排序。在默认的情况下，TreeSet采用自然排序。1、自然排序：TreeSet会调用集合元素的compareTo(Objectobj)方法来比较元素之间的大小关系，然后让集合按照升序排列，这种方式叫做自然排序。2、定制排序：定制排序是按照使用者的要求，需要自己设计的一种排序。如果需要定制排序，比如需要数据按照降序排列，则可以通过Comparator接口的帮助。TreeSet的一些其他方法：1234567891011121314//返回此 set 中当前最后一个（最高）元素。ts.last();//返回此 set 中当前第一个（最低）元素。ts.first();//返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。ts.ceiling(e);//返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。ts.floor(e);//返回 set 中的元素数（set 的容量）。ts.size(); PS:1、如果希望TreeSet能够正常运行，TreeSet只能添加同一种类型的对象。2、TreeSet集合中判断元素相等的唯一标准是：两个对象通过comparator（Objectobj）方法比较后，返回0；否则认为不相等。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.nerokey.iofo/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.nerokey.iofo/tags/java/"},{"name":"集合","slug":"集合","permalink":"http://www.nerokey.iofo/tags/集合/"}]},{"title":"Java中的集合之List","slug":"Java中的集合之List","date":"2017-11-08T09:42:19.000Z","updated":"2017-11-11T07:17:46.047Z","comments":true,"path":"2017/11/08/Java中的集合之List/","link":"","permalink":"http://www.nerokey.iofo/2017/11/08/Java中的集合之List/","excerpt":"java中list是一个接口，已实现的类有ArrayList、LinkedList等。 List的特点：1 . List：序列2 . 有序的，可重复3 . ArrayList：顺序4 . LinkedList：离散","text":"java中list是一个接口，已实现的类有ArrayList、LinkedList等。 List的特点：1 . List：序列2 . 有序的，可重复3 . ArrayList：顺序4 . LinkedList：离散 ArrayListArrayList就相当于一个容器，任何元素都能往里面丢。他的特点就是：1 . 顺序结构2 . 容量动态扩充3 . 线程不安全（不同步） 下面给出了ArrayList的一些常用方法：1、添加元素：我们使用add方法向里面添加元素，像这样：12345678910ArrayList ls = new ArrayList(); //创建一个list对象ls.add(&quot;abcd&quot;);ls.add(111);ls.add(3.1415);ls.add(null);ls.add(false);ls.add(&quot;abcd&quot;);ls.add(new Person(&quot;abc&quot;, 20));ls.add(new Person(&quot;123bc&quot;, 18)); 可以看出这个容器中不仅能放int类型，double类型，boolean类型等基本数据类型，甚至是null值也能存放、对象也能放进去，并且允许存放相同元素。2、容器中的元素输出：12345//使用迭代器输出Iterator iter = ls.iterator();while(iter.hasNext())&#123; System.out.println(iter.next());&#125; 注意： ArrayList无法使用for循环输出，需要使用迭代器while循环输出，hasNext()判断是否有下一个元素，next()输出元素对象。3、其他一些方法：1234567891011121314//get方法，获取index下标的对象System.out.println(ls.get(4));//size方法，获取当前ArrayList容器里面元素的个数int size = ls.size();//indexOf，获取容器中某个对象的下标索引System.out.println(ls.indexOf(111));//remove，移除指定下标的元素值ls.remove(5);//clear，清空整个容器ls.clear(); 此外ArrayList中还包括clone()啊之类的一些其他方法，就不一一列举了。。 LinkedList他的底层是通过链表实现的，所以他不仅具有ArrayList的方法，还具有队列和栈的一些操作。其特点为：1 . 离散结构2 . 容量动态扩充3 . 线程不安全（不同步） 这里我们就举一些和ArrayList不同的例子1、添加元素和ArrayList是一样的使用add()方法1234567891011LinkedList list = new LinkedList(); list.add(&quot;abcd&quot;);list.add(111);list.add(3.1415);list.add(null);list.add(true);list.add(3.1415);list.add(&quot;abcd&quot;);list.add(new Person(&quot;abc&quot;, 20));list.add(new Person(&quot;123bc&quot;, 18)); 这里也是允许添加相同的元素。2、遍历方法：和ArrayList一样使用Iterator迭代器来遍历3、其他一些常用方法：(与ArrayList不同的方法)1234567891011121314151617181920//从此列表所表示的堆栈处弹出一个元素。list.pop(); //在列表尾部添加一个元素list.addLast(&quot;ABC&quot;); //在列表头部添加一个元素list.addFirst(&quot;China&quot;); //获取列表最后一个元素list.getLast(); //获取列表第一个元素list.getFirst(); //获取但不移除此列表的头（第一个元素）。list.peek(); //将元素推入此列表所表示的堆栈。list.push(100); 注意： pop()和peek()还有getFirst()都能获取列表的第一个元素，但是pop()是会将元素删除，其他两个方法都不会将其删除。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.nerokey.iofo/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.nerokey.iofo/tags/java/"},{"name":"集合","slug":"集合","permalink":"http://www.nerokey.iofo/tags/集合/"}]},{"title":"Win10+Ubuntu16.04双系统安装","slug":"Win10-Ubuntu16-04双系统安装","date":"2017-10-23T23:14:49.000Z","updated":"2017-10-24T02:18:27.915Z","comments":true,"path":"2017/10/24/Win10-Ubuntu16-04双系统安装/","link":"","permalink":"http://www.nerokey.iofo/2017/10/24/Win10-Ubuntu16-04双系统安装/","excerpt":"1、今天我们来看看uefi+gpt下Win10+Ubuntu16.04双系统如何安装。首先附上我的引导界面","text":"1、今天我们来看看uefi+gpt下Win10+Ubuntu16.04双系统如何安装。首先附上我的引导界面我的安装条件： 1. win10笔记本一台 SSD+机械盘 2. U盘一个（大于4G） 3. Ubuntu16.04的iso镜像 个人是有2块硬盘的，其中SSD安装的是win10；使用了机械的80G用于安装Ubuntu，剩下的用来做数据盘。引导也是放在固态盘中的，这样启动会快上一些。当然，如果你只有一块硬盘应该也是一样的。2、然后是安装过程：","categories":[{"name":"Linux系统","slug":"Linux系统","permalink":"http://www.nerokey.iofo/categories/Linux系统/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.nerokey.iofo/tags/Linux/"},{"name":"系统安装","slug":"系统安装","permalink":"http://www.nerokey.iofo/tags/系统安装/"}]},{"title":"javascript中的前端表单验证","slug":"javascript中的前端表单验证","date":"2017-10-23T13:58:34.000Z","updated":"2017-10-23T23:06:51.548Z","comments":true,"path":"2017/10/23/javascript中的前端表单验证/","link":"","permalink":"http://www.nerokey.iofo/2017/10/23/javascript中的前端表单验证/","excerpt":"在Web中最常见的就是表单验证了，因为现在基本上各大网站都要求登入账号，这时候验证账号和密码的准确性就需要用到表单验证。当然通常情况下都会前端后端都需要进行验证，因为单一前端验证容易出现漏洞；而只进行后端验证则会加大对服务器的压力。所以就有了前端验证格式正确与否，而后端验证账号密码匹配与否。大致有两种写法可以实现：","text":"在Web中最常见的就是表单验证了，因为现在基本上各大网站都要求登入账号，这时候验证账号和密码的准确性就需要用到表单验证。当然通常情况下都会前端后端都需要进行验证，因为单一前端验证容易出现漏洞；而只进行后端验证则会加大对服务器的压力。所以就有了前端验证格式正确与否，而后端验证账号密码匹配与否。大致有两种写法可以实现： 1、在按钮的check事件中进行验证，验证通过后使用form.submit()发送验证 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name=&quot;myform&quot; action=&quot;do.php&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;username&quot;&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;/p&gt; &lt;/label&gt; &lt;label for=&quot;psword&quot;&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;psword&quot; id=&quot;psword&quot;&gt;&lt;/p&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;登录&quot; onclick=&quot;check()&quot;&gt; &lt;/form&gt; &lt;script&gt; function check()&#123; with(document.myform)&#123; if(username.value.length==0)&#123; // if(username.value==&quot;&quot;) alert(&apos;用户名必须输入！&apos;); username.focus(); &#125; else if(psword.value.length==0)&#123; alert(&apos;密码不能为空&apos;); psword.focus(); &#125; else myform.submit(); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、在表单的onsubmit表单中进行验证 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name=&quot;myform&quot; action=&quot;do.php&quot; method=&quot;POST&quot; onsubmit=&quot;return checkdata()&quot;&gt; &lt;label for=&quot;username&quot;&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;/p&gt; &lt;/label&gt; &lt;label for=&quot;password&quot;&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;/p&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;script&gt; function checkdata()&#123; with(document.myform)&#123; if(username.value==&quot;&quot; || password.vlaue==&quot;&quot;)&#123; alert(&apos;用户名或密码不能为空！&apos;); return false; &#125; else&#123; return true; &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 常用的其他验证： 1、必填字段验证：1234//if(value==null||value==&quot;&quot;) if(value.length==0)&#123; alert(&apos;必须输入&apos;)； &#125; 2、长度验证：123if(value.length&gt;50)&#123; alert(&apos;不能超过50个字符&apos;);&#125; 3、只能输入数字验证：1234567891011function isNumber(String)&#123; var Letters = &quot;1234567890&quot;; //可以自己增加可输入值 var i; var c; for( i = 0; i &lt; String.length; i++)&#123; c = String.charAt( i ); if (Letters.indexOf( c ) &lt; 0) return false; &#125; return true;&#125; 4、邮箱验证：1234567function isEmail(value)&#123; apos=value.indexOf(&quot;@&quot;) dotpos=value.lastIndexOf(&quot;.&quot;) if (apos&lt;1||dotpos-apos&lt;2) &#123; return false&#125; else &#123;return true&#125;&#125; 以上是前端各种验证的关键部分，具体扩充看具体需求了。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.nerokey.iofo/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.nerokey.iofo/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"http://www.nerokey.iofo/tags/前端/"}]},{"title":"Java中不借助中间变量交换两数的值","slug":"Java中不借助中间变量交换两数的值","date":"2017-10-22T09:02:42.000Z","updated":"2017-11-08T14:48:01.547Z","comments":true,"path":"2017/10/22/Java中不借助中间变量交换两数的值/","link":"","permalink":"http://www.nerokey.iofo/2017/10/22/Java中不借助中间变量交换两数的值/","excerpt":"交换数值我们一般借助一个中间变量，这样会变得简单明了。然而在面试的时候很多面试官就喜欢这样来问你，这时候如果你回答出来了就能显得你稍稍厉害一些。 今天我们就来看看Java中是如何不借助第三个变量来交换数值的再此之前我们先看下借助第三个变量来交换法1234567891011121314public class Exchange1 &#123; public static void main(String[] args) &#123; int x = 10; int y = 18; System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); System.out.println(&quot;---------交换后------------&quot;); int temp; temp = x; x = y; y = temp; System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); &#125;&#125;","text":"交换数值我们一般借助一个中间变量，这样会变得简单明了。然而在面试的时候很多面试官就喜欢这样来问你，这时候如果你回答出来了就能显得你稍稍厉害一些。 今天我们就来看看Java中是如何不借助第三个变量来交换数值的再此之前我们先看下借助第三个变量来交换法1234567891011121314public class Exchange1 &#123; public static void main(String[] args) &#123; int x = 10; int y = 18; System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); System.out.println(&quot;---------交换后------------&quot;); int temp; temp = x; x = y; y = temp; System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); &#125;&#125; 结果为：方法有两种：其一是通过数学方法，对这两个数进行某些数学运算；其二是通过位运算。 １．数学运算法 123456789101112public class Exchange2 &#123; public static void main(String[] args) &#123; int x = 7; int y = 4; System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); x = x+y; //x=11 y = x-y; //y=7 x = x-y; //x=4 System.out.println(&quot;--------交换后--------&quot;); System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); &#125;&#125; 结果为： 2．位运算法 123456789101112public class Exchange3 &#123; public static void main(String[] args) &#123; int x = 16; int y = 21; System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); x = x^y; y = y^x; x = y^x; System.out.println(&quot;--------交换后--------&quot;); System.out.println(&quot;x=&quot;+x+&quot;,y=&quot;+y); &#125;&#125; 结果为：这里我们用到的位运算是异或运算。不明白的同学可以将两个数化成二进制一步一步算一下就能明白了。 好了，这就是java中不借助第三个变量来实现两个数的数值互换的两种基本方法，可能还有更高级的方法，就不一一列举了。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.nerokey.iofo/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.nerokey.iofo/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://www.nerokey.iofo/tags/算法/"}]},{"title":"一般网站导航栏的写法","slug":"一般网站导航栏的写法","date":"2017-10-21T07:46:57.000Z","updated":"2017-10-22T09:35:06.217Z","comments":true,"path":"2017/10/21/一般网站导航栏的写法/","link":"","permalink":"http://www.nerokey.iofo/2017/10/21/一般网站导航栏的写法/","excerpt":"今天我们用html+css实现一些网站导航栏效果 很多网站的导航页面都是具有鼠标放上就展开下拉内容这个功能 比如说下面这个网站：","text":"今天我们用html+css实现一些网站导航栏效果 很多网站的导航页面都是具有鼠标放上就展开下拉内容这个功能 比如说下面这个网站： 1、我们首先用两个盒子来说明下原理12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; height: 30px; width: 60px; background-color: #ccc; &#125; .show&#123; display: none; height: 50px; width: 100px; background-color: #fcc; &#125; .box:hover .show&#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;盒子1 &lt;div class=&quot;show&quot;&gt;盒子2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 原本只显示盒子1，当鼠标放上去后便会展开盒子2了。首先html部分很简单，就是两个盒子的嵌套然后看css部分：➀ 我们先将盒子2设置display:none将其隐藏➁123.box:hover .show&#123; display: block;&#125; 这一段的意思就是当鼠标放在.box类上是对.show类操作。前提是.show得是.box的子集，就是包含在.box中这里我们设置的是将.show类展开，即display:block。这样就实现了我们的核心功能。 2、接下来我们做上面示例图中的导航页面只要理解了原理，做出图例的样式其实很简单了代码如下： ① 首先是html代码123456789&lt;body&gt; &lt;a href=&quot;#&quot; class=&quot;head&quot;&gt;首页&lt;/a&gt; &lt;div class=&quot;box&quot;&gt;评价任务 ▾ &lt;div class=&quot;show&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;评价任务&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;topborder&quot;&gt;淘宝问大家&lt;/a&gt;&lt;/li&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 这是body部分代码，很简单。就是写了个a标记，然后一个div里面再嵌一个div实现。 ② CSS部分代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt; *&#123;margin: 0;padding: 0;&#125; body&#123; margin: 60px; &#125; .head, .box&#123; float: left; line-height: 50px; width: 200px; background-color: #4882F0; color:#fff; text-decoration: none; text-align: center; &#125; .box&#123; overflow: hidden; &#125; .show&#123; display: none; border: 1px dotted #ccc; &#125; .box:hover&#123; font-weight: bold; background-color: #3B6CCA; &#125; .head:hover&#123; font-weight: bold; background-color: #3B6CCA; &#125; .box:hover .show&#123; font-weight: normal; display: block; background-color: #fff; border-top:2px solid #F09628; &#125; .topborder&#123; border-top:1px dotted #ccc; &#125; li&#123; display: inline-block; &#125; .show a&#123; text-align:center; padding: 10px 50px; text-decoration: none; color:#000; &#125; .show a:hover&#123; color:#F09628; &#125;&lt;/style&gt; 结构很清晰，这样就能实现示例图的效果了。 总结其实我们只要理解前面的盒子嵌套模型，其他的就都是一样的原理，万变不离其宗。都是一个道理。","categories":[{"name":"前端","slug":"前端","permalink":"http://www.nerokey.iofo/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.nerokey.iofo/tags/html/"},{"name":"css","slug":"css","permalink":"http://www.nerokey.iofo/tags/css/"}]},{"title":"Markdown文件的基本书写","slug":"md文件的书写格式","date":"2017-10-01T00:31:01.000Z","updated":"2017-10-23T13:24:40.383Z","comments":true,"path":"2017/10/01/md文件的书写格式/","link":"","permalink":"http://www.nerokey.iofo/2017/10/01/md文件的书写格式/","excerpt":"1. 首先推荐一个在线编辑器 Cmd Markdown在线编辑器，可以实时预览到博客的样子点击Markdown进入开始编写。","text":"1. 首先推荐一个在线编辑器 Cmd Markdown在线编辑器，可以实时预览到博客的样子点击Markdown进入开始编写。 2. Markdown的基本语法1、 标题的写法用#号表示标题，比如说“#一级标题”表示一级标题，相当于html中的h1。和html一样也是有6级标题的，分别用“#”，“##”，“###”，······ 以此类推表示标题。 1234# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题 效果如下： 或者可以这样写 123# 这是一级标题 ### 这是二级标题 ##### 这是三级标题 ### 效果如下： 这样就相当于有了闭合标签一般来说选择第一种写法，比较方便快捷；注意#和标题内容之间有空格。 2、 列表 列表分为有序列表和无序列表。下面直接展示写法和效果 123456#### 无序列表* 1 * 1.1 * 1.1.1* 2* 3 效果如下： 可以看到如果代码缩进就会变成次级列表，出来*号可以用来表示列表以外，还可以使用+，-来表示无序列表。 12345#### 有序列表1. 有序列表1 1. 次级列表2. 有序列表2 3. 有序列表3 效果如下： 3、 区块引用 如果你想把某些内容放在一起或者是引用某某某的话时就可以使用引用了。使用也很简单就是在你要引用话之前加一个&gt;，注意是英文箭头，还有在&gt;和话之间是需要空格的 比如这样： 123456&gt; ### 这是引用&gt; * 不以结婚为目的的谈恋爱都是耍流氓&gt; &gt; 这是毛主席说的&gt; * 前方高能&gt; &gt; 注意：这里是为了提醒前面很刺激&gt; &gt; 的事情要发生 同样引用也是可以嵌套的比如这样： 12345&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用&gt;&gt;&gt;&gt; 四级引用&gt;&gt;&gt;&gt;&gt; 五级引用 效果如下：多级引用嵌套可以不要连在一起的，中间允许有空格，只要在一行就行 4、分割线 分割线可以由 *，-，_这3个符号最少3个，可连续也可不连续，最少3个就行 1234---___* * **** 效果如下： 不过一般情况我们选择 ——–这个符号，因为易写，直观明了。 5、 链接链接的写法有两种：行内式和参数式，不管是哪一种，链接文字都需要用[]来标记 12##### 行内式[行内式](https://www.baidu.com)链接的写法 效果图： 12345#### 参数式[name]:https://www.baidu.com[主页]:https://www.baidu.com这里是 [name]，这里是[主页] 效果图： 一般会这两种方法就差不多了 6、 图片图片的写法就和链接基本一样了。这里就直接给出写法，很容易理解的 12#### 图片的写法这里放图片![我是图片](http://i4.bvimg.com/524586/602c9d1be6eecc97s.png) 显示效果： 图片的写法和链接几乎一样只是前面多了一个!用来表示图片。 7、 代码框这个就很重要了，很多时候你都只是想吧自己的代码贴上去。这时候就要用到这个了。如果代码只有一行，那很简单，直接用`引起来就好了。如果代码是多行的话，就需要用```表示开始，同样用三个点表示结束，代码写在中间像这样 代码的写法： 显示效果： 8、 表格这个写起来有点麻烦，其实有点像你就是在用符号画表格。例如： 123456#### 表格| name | age | sex ||:----:|:---:|:---:|| Tom | 28 | 男 || Jany | 23 | 女 || Lucy | 26 | 女 | 效果图： 或者这样写： 12345#### 表格 姓名|语文|数学|英语 -|-|-|- Tom|80|70|84 Jane|90|88|92 效果图： 9、 强调强调就是加粗和倾斜还有删除线，有的时候用得着。 12345678#### 倾斜_倾斜_*倾斜*#### 加粗__加粗__**加粗**#### 删除线~~删除线~~ 效果图： 10、 转义字符其实就是有些符号代表了特殊意义导致无法输入，这时候就需要转义字符了。其实很简单，转义字符和js的转义字符是一样的，这里我就列几个常用的。 1234567#### 转义字符* \\\\* \\`* \\** \\-* \\+* \\! 效果图： 编写md文件的基本语法差不多就这些了，也是从网上各处整理的。日后如果需要再进行补充。","categories":[{"name":"博客相关","slug":"博客相关","permalink":"http://www.nerokey.iofo/categories/博客相关/"}],"tags":[{"name":"md语法","slug":"md语法","permalink":"http://www.nerokey.iofo/tags/md语法/"},{"name":"md书写格式","slug":"md书写格式","permalink":"http://www.nerokey.iofo/tags/md书写格式/"}]}]}